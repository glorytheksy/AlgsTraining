package regexp;

/**
 * 1. 正则表达式需求：
 * 
 * 例如：找出四个数字连在一起的子串
 *      且第一位与第四位相同，第二位与第三位相同
 *      
 *      电子邮件格式是否符合规定
 * 
 * 2. 转义符号\\
 *   检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果
 *   常用：
 *       .*+()$/\?[]^{}
 *   
 *   在java中，两个\\代表其他语言中的一个\
 * 
 * 3. 正则表达式语法
 *   1) 限定符(限定出现的次数)
 *     * 指定字符重复0次或者n次
 *     + 指定字符重复1次或者更多
 *     ? 指定字符0词或者1次
 *     {n} n次
 *     {n,m} 至少n次, 至多m次
 *   2) 选择匹配符(可以选择a出现还是b出现)
 *     |
 *   
 *   3) 分组组合和反向引用 (用的比较多)
 *     捕获分组
 *     (pattern) 非命名捕获, 捕获匹配的子串。编号为0的第一个捕获是有整个正则匹配的文本, 其它捕获
 *     根据左括号的顺序从1开始自动编号(代码详见RegTheory.java)
 *     (?<name>pattern) 命名捕获, 区别只在于捕获多了个名字, 相当于给group取了一个名字, 这时, 
 *     既可以用编号, 也可以用组名
 *     
 *     非捕获分组(年代比较久, 老程序员喜欢用, 这里先不介绍，遇到了再看韩老师视频)
 *     
 *     贪婪匹配和非贪婪匹配
 *     我们默认是贪婪匹配(尽可能匹配的多)
 *     在regExp后边加一个?, 就是非贪婪匹配(尽可能少)
 *     例如, hello111111 ok, regExp=\\d+为贪婪, \\d+?就是非贪婪
 *     
 *     反向引用(例如需求，4位数字，第一位和第四位相同)
 *     圆括号的内容被捕获之后, 可以在这个括号后被使用，这个我们称之为"反向引用"
 *     这种引用既可以是正则表达式内部，也可以是外部
 *     内部\\分组号，外部$分组号
 *     例子：
 *     1. 要匹配两个连续的相同数字:(\\d)\\1
 *     2. 要匹配5个连续的相同数字:(\\d)\\1{5}
 *     3. 要1位和4位相同:(\\d)[0-9]{2}\\1
 *     
 *     
 *   
 *   
 *   4) 特殊字符
 *   5) 字符匹配符
 *     []表示匹配括号里的任意一个
 *     [^]表示不接受的字符，比如[^abc]表示不是abc的字符
 *     -表示连字符，表示范围，比如A-Z表示所有大写字母
 *     .匹配\n以外的任何字符，比如a..b，表示开头为a结尾为b的任意长度为4的字符
 *     \\d匹配单个数字字符，相当于[0-9]
 *     \\D匹配单个非数字字符，相当于[^0-9]
 *     \\w匹配当个数字、大小写字母字符，相当于[0-9a-zA-Z]
 *     \\W匹配当个非数字、大小写字母字符，相当于[^0-9a-zA-Z]
 *   6) 定位符(规定匹配的字符要出现的位置)
 *     ^ 起始字符(常用)
 *     $ 指定结束字符(常用)
 *     \\b 匹配布标字符串的边界(也就是有空格), 比如 han\\b, 字符串为 hanshunpin sphan nnhan,则第一个han匹配不到
 *         因为第一个han的右边并不是边界状态
 *     \\B 匹配目标字符串的非边界, 和\\b相反
 *
 * 
 * 
 * 
 * 
 * 
 * 
 */